<!DOCTYPE html>
<html>
  <head>
    <title>Sankeertan</title>
    <style>
      #content {
        width: 80%;
        height: 500px;
        border: 1px solid #ccc;
        overflow-y: auto;
      }
    </style>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
  </head>
  <body>
    <textarea id="contentInput" placeholder="Paste content here"></textarea
    ><br />
    <button id="sendContent">Send Content</button><br />
    <label
      ><input type="checkbox" id="scrollBroadcast" /> Broadcast Scroll</label
    ><br />
    <div id="content"></div>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script>
      window.addEventListener("load", function () {
        const supabaseUrl = "https://radtpoqypgqetijvopho.supabase.co";
        const supabaseAnonKey =
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJhZHRwb3F5cGdxZXRpanZvcGhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3ODAwNjAsImV4cCI6MjA1NzM1NjA2MH0.dAIWitCyN4TVv3n4PTvhqJlUXsAGVSjOPm-L2jw818k";
        const client = supabase.createClient(supabaseUrl, supabaseAnonKey);
        const contentInput = document.getElementById("contentInput");
        const sendContentButton = document.getElementById("sendContent");
        const contentDiv = document.getElementById("content");
        const scrollBroadcastCheckbox = document.getElementById("scrollBroadcast");
        // Initial data fetch
        async function fetchInitialData() {
          const { data, error } = await client
            .from("sankeertan")
            .select("*")
            .eq("id", 1)
            .single();
          if (data) {
            contentDiv.innerHTML = data.content;
            contentDiv.scrollTop = data.scroll_position;
            setTimeout(observeRows,100);
          }
        }
        fetchInitialData();

        sendContentButton.addEventListener("click", async () => {
          await client
            .from("sankeertan")
            .upsert({ id: 1, content: contentInput.value });
          contentDiv.innerHTML = contentInput.value;
          contentInput.value = "";
          setTimeout(observeRows,100);
        });

        /*contentDiv.addEventListener("scroll", async () => {
          return;
          if (scrollBroadcastCheckbox.checked) {
            await client
              .from("sankeertan")
              .upsert({ id: 1, scroll_position: contentDiv.scrollTop });
          }
        });
        */
        client
          .channel("sankeertan")
          .on("UPDATE", (payload) => {
            if (payload.new.id === 1) {
              contentDiv.innerHTML = payload.new.content;
              contentDiv.scrollTop = payload.new.scroll_position;
              setTimeout(observeRows,100);
            }
          })
          .subscribe();

          function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
              clearTimeout(timeoutId);
              timeoutId = setTimeout(() => {
                func.apply(this, args);
              }, delay);
            };
          }
          async function sendScrollSync(idStr) {
            console.log("here001::"+idStr);
            if(scrollBroadcastCheckbox.checked){
              const id = idStr.match(/\d+/g).map(Number)[0];
              console.log("sending scroll id as ::"+id);
              try {
                await client.from('sankeertan').upsert({ id: 1, scroll_position: id });
                console.log('Upsert successful'); // Add a log message
              } catch (error) {
                console.error('Upsert failed:', error); // Log the error
              }
            }
          }
          
          const debouncedSendForScrollSync = debounce(sendScrollSync, 1000); 
          
function observeRows() {
  const observer = new IntersectionObserver((entries) => {
    let topVisibleEntry = null;

    // Create a deep copy of entries
    const entriesCopy = entries.map(entry => ({
      target: entry.target,
      isIntersecting: entry.isIntersecting,
      boundingClientRect: { ...entry.boundingClientRect },
      intersectionRatio: entry.intersectionRatio,
      intersectionRect: { ...entry.intersectionRect },
      rootBounds: entry.rootBounds ? { ...entry.rootBounds } : null,
      time: entry.time,
    }));

    console.log('Original Entries:', entriesCopy.map(e => ({ id: e.target.id, top: e.boundingClientRect.top }))); // Log original entries

    const reversedEntries = [...entriesCopy].reverse();

    console.log('Reversed Entries:', reversedEntries.map(e => ({ id: e.target.id, top: e.boundingClientRect.top }))); // Log reversed entries

reversedEntries.forEach((entry) => {
    if (entry.isIntersecting && entry.boundingClientRect.top >= 0) {
        console.log('Entry:', entry.target.id, entry.boundingClientRect.top); // Log entry values
        console.log('topVisibleEntry:', topVisibleEntry ? topVisibleEntry.target.id : null); // Log topVisibleEntry

        if (!topVisibleEntry || entry.boundingClientRect.top < topVisibleEntry.boundingClientRect.top) {
            topVisibleEntry = entry;
            console.log('New Top Visible Entry:', entry.target.id, entry.boundingClientRect.top); // Log new top visible entry
        }
    }
});


    if (topVisibleEntry) {
      const visibleRowId = topVisibleEntry.target.id;
      debouncedSendForScrollSync(visibleRowId);
    } else {
      
	  .forEach((entry) => {
        if (entry.isIntersecting) {
          const visibleRowId = entry.target.id;
          debouncedSendForScrollSync(visibleRowId);
          return;
        }
      });
    }
  }, { threshold: 0 });

  const rows = document.querySelectorAll('tr[id]');
  rows.forEach(row => {
    observer.observe(row);
  });
}
      });
    </script>
  </body>
</html>
